{"0": {
    "doc": "Ch5 - Replication",
    "title": "Leader-follower replication",
    "hpath": "books.tech.data-intensive-applications.ch5-replication",
    "content": ". | Leader take writes, all can take reads | Used by: . | relational: PostgreSQL, MySQL, Oracle Data Guard, SQL Server AlwaysOn Availability Groups | noSQL: MongoDB, RethinkDB, Espresso | Kafka, RabbitMQ | . | Sync vs Async replication . | impractical for all followers to be synchronous | if database is configured for sync, usually one of followers is sync, others are async - “semi-synchronous” | . | Implementation of Replication Logs . | Statement-based replication . | not generally used (MySQL before 5.1), because problems: . | nondeterministic functions e.g. NOW() or RAND() | autoincrementing columns | side effects (triggers, UDFs, etc) | . | . | Write-ahead-log shipping . | WAG: in log structured storage engine, main palce for store. in Btree, WAL before B tree modified | used in PostgreSQL and Oracle | disadvantage: log very low level - specific disk block and bytes -&gt; problem: zero-downtime upgrade not possible if leader and follower can’t run with different version of storage engine | . | Logical (row-based) log replication . | decoupled from storage engine internals | used by MySQL binlog | also can be used by external system, CDC | . | trigger-based - application layer . | Oracle GoldenGate or triggers and Stored Procs | . | . | Dealing with replication lag and eventual consistency . | Reading Your Own Writes . | option 1: When reading something that the user may have modified, read it from the leader; otherwise, read it from a follower. | option 2: track time of last update, and query leader when within some time window | option 3: client can remember timestamp and require serving replica up to date | . | Monotonic Reads: second read lags behind first read . | option 1: read from same replica | option 2: use sequencer? | . | consistent prefix read: causual events observed out of order . | option 1: causal udpates in the same partition | . | using transactions - for a database to provide stronger guarantees so that the application can be simpler. | . | . ",
    "url": "http://localhost:4000/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#leader-follower-replication",
    "relUrl": "/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#leader-follower-replication"
  },"1": {
    "doc": "Ch5 - Replication",
    "title": "Multi-leader replication",
    "hpath": "books.tech.data-intensive-applications.ch5-replication",
    "content": ". | use case: . | multi-datacenter | Clients with offline operation . | offline device each has a local database that acts as leader | . | Collaborative editing | . | conflict detection likely async - if sync, might as well use single leader | conflict avoidance . | different “home” cluster for diff users | . | achieving convergent conflict resolution . | each write unique ID, pick the highest ID | assign priority between writers | merge the values e.g. concat. | record the conflict | . | custom conflict resolution logic . | on write | on read | . | auto conflict resolution research: . | Conflict-free replicated datatypes (CRDTs) - family of data structures for sets, maps, ordered lists, counters, etc . | CRDTs slide deck | . | Mergeable persistent data structures - like Git, 3 way merge function . | Mergeable Persistent Data Structures paper | . | Operational transformation for collab. editing e.g. Google Docs. | papaer | . | . | Multi-Leader Replication Topologies . | all-to-all, circular, or star (generalize to trees) | circular or star topology may be broken with one failed node | all-to-all has problem of inconsistent ordering | . | . ",
    "url": "http://localhost:4000/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#multi-leader-replication",
    "relUrl": "/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#multi-leader-replication"
  },"2": {
    "doc": "Ch5 - Replication",
    "title": "Leaderless Replication - quorum based",
    "hpath": "books.tech.data-intensive-applications.ch5-replication",
    "content": ". | “Dynamo-style” - Riak, Cassandra, and Voldemort, inspired by Amazon Dynamo | catch-up options: . | Read repair - reader can detect stale response and update | anti-entropy - background process | . | quorum condition: w + r &gt; n - b.c. set of nodes for w and r must overlap | issues with quorum: . | write partial failure needs to be rolled back | eventual consistent without the type of replication lag gaurantees - hard to quantify | difficult to mointor staleness | . | sloppy quorum: writes and reads still require w and r successful responses, but those may include nodes that are not among the designated n “home” nodes for a value. | once network inerruption is fixed, writes go back to “home” nodes - hinted handoff. so reads might not see the update. | . | Multi-datacenter: . | Cassandra and Voldemort extends quorum to multi-datacenter. high latency writes to other datacenters often async. | Riak - all local. cross-dc happen async in the background | . | concurrent writes: . | the application developer neesd to understand the internals on this | Last write wins based on a timestamp . | only option in Cassandra | optionl on Riak | only safe way: each key is immutable | . | The “happens-before” relationship: . | B depends on A - “happens-before” | A and B are independent - concurrent | . | Option 1: Capturing the happens-before relationship (client send version number it depends on) . | server maintain version for each key | when client writes, must include the version of a prev read and merge with it | server can clean up versions &lt;= version number received in the write - since it knows it has been merged. then incre curr version # and return it in response | . | Option 2: Merging concurrently written values . | for collections, just union the writes | deletes require a tombstones with a version number | . | version vectors: multiple replicas, each need a version number . | collection of version numbers for all replicats | Dotted Version Vectors: Logical Clocks for Optimistic Replication paper | . | . | . ",
    "url": "http://localhost:4000/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#leaderless-replication---quorum-based",
    "relUrl": "/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#leaderless-replication---quorum-based"
  },"3": {
    "doc": "Ch5 - Replication",
    "title": "Summary",
    "hpath": "books.tech.data-intensive-applications.ch5-replication",
    "content": ". | Single-leader replication is popular because it is fairly easy to understand and there is no conflict resolution | Multi-leader and quorum based can be more robust in the presence of faulty nodes, network interruptions, and latency spikes—at the cost of being harder to reason about and providing only very weak consistency guarantees. | . ",
    "url": "http://localhost:4000/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#summary",
    "relUrl": "/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#summary"
  },"4": {
    "doc": "Ch5 - Replication",
    "title": "Reseach: Chain replication",
    "hpath": "books.tech.data-intensive-applications.ch5-replication",
    "content": ". | Chain Replication for Supporting High Throughput and Availability paper | Object Storage on CRAQ High-throughput chain replication for read-mostly workloads paper | Windows Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency paper | . ",
    "url": "http://localhost:4000/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#reseach-chain-replication",
    "relUrl": "/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html#reseach-chain-replication"
  },"5": {
    "doc": "Ch5 - Replication",
    "title": "Ch5 - Replication",
    "hpath": "books.tech.data-intensive-applications.ch5-replication",
    "content": "Reasons for multi-machine: . | scalability | HA | latency (route user closer to them) | Disconnected operation | . Scaling . | shared-memory | shared-disk - e.g. Oracle RAC? | shared-nothing . i.e. horizontal scaling | . ",
    "url": "http://localhost:4000/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html",
    "relUrl": "/notes/28cfed31-0166-4784-a7d6-c76d3fcd269e.html"
  },"6": {
    "doc": 404,
    "title": "404",
    "hpath": null,
    "content": "Page not found . ",
    "url": "http://localhost:4000/404.html#404",
    "relUrl": "/404.html#404"
  },"7": {
    "doc": 404,
    "title": 404,
    "hpath": null,
    "content": " ",
    "url": "http://localhost:4000/404.html",
    "relUrl": "/404.html"
  },"8": {
    "doc": "Ch7 - Transactions",
    "title": "ACID definition is slippery",
    "hpath": "books.tech.data-intensive-applications.ch7-transactions",
    "content": ". | Atomicity: . | different from normal meaning in concurrency programming (nobody else sees a partially updated state) | means more abortability - when failure, all partial updates are reverted | . | Consistency: . | overloaded term | means some invariants to be true - but it’s more up to application. | ‘C’ doesn’t really belong | . | Isolation: . | concurrently executing transactions are isolated from each other: they cannot step on each other’s toes | i.e. serializability - result is the same as if they had run serially | in practice, strictly serializable isolation is rarely used. Oracle 11g doesn’t even implement it. | . | . ",
    "url": "http://localhost:4000/notes/603d252d-91ec-4f35-950e-26211cd5112a.html#acid-definition-is-slippery",
    "relUrl": "/notes/603d252d-91ec-4f35-950e-26211cd5112a.html#acid-definition-is-slippery"
  },"9": {
    "doc": "Ch7 - Transactions",
    "title": "Ch7 - Transactions",
    "hpath": "books.tech.data-intensive-applications.ch7-transactions",
    "content": "purpose of transactions: simplify the programming model . ",
    "url": "http://localhost:4000/notes/603d252d-91ec-4f35-950e-26211cd5112a.html",
    "relUrl": "/notes/603d252d-91ec-4f35-950e-26211cd5112a.html"
  },"10": {
    "doc": "Data-intensive-applications",
    "title": "Data-intensive-applications",
    "hpath": "books.tech.data-intensive-applications",
    "content": " ",
    "url": "http://localhost:4000/notes/a42eba1d-b978-4cdc-9160-1f3e9c7cf025.html",
    "relUrl": "/notes/a42eba1d-b978-4cdc-9160-1f3e9c7cf025.html"
  },"11": {
    "doc": "Ch6 - Partitioning",
    "title": "Partitioning by Key Range",
    "hpath": "books.tech.data-intensive-applications.ch6-partitioning",
    "content": ". | used by BigTable, open source equivalent HBase, MongoDB before v2.4 | sorted in each partition: range scanes are easy | con: hot spots | . ",
    "url": "http://localhost:4000/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#partitioning-by-key-range",
    "relUrl": "/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#partitioning-by-key-range"
  },"12": {
    "doc": "Ch6 - Partitioning",
    "title": "partition by hash key",
    "hpath": "books.tech.data-intensive-applications.ch6-partitioning",
    "content": ". | choice of hash key: . | Cassandra and MongoDB use MD5, Vodemort uses Fowler– Noll–Vo function. | MurmurHash - non-cryptographic but lightweight | built-in Java hash function is bad, because same key -&gt; different hash . | it’s built for in memory hash tables and the behavior is a safety mechanism to prevent collding hash attacks | . | . | Consistent Hashing . | great for caches | does not work great for DBs | . | range query difficult - Cassandra and DynamoDB uses hash + sort ey | hotspot relief: application level - route writes to multiple keys: key_random_num | . ",
    "url": "http://localhost:4000/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#partition-by-hash-key",
    "relUrl": "/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#partition-by-hash-key"
  },"13": {
    "doc": "Ch6 - Partitioning",
    "title": "Secondary Indexes",
    "hpath": "books.tech.data-intensive-applications.ch6-partitioning",
    "content": ". | local index - scatter writes, gather for eads . | Used by MongoDB, Riak, Cassandra, Elasticsearch, SolrCloud, and VoltDB | . | global index . | write reaches multiple partitions - distributed transaction or async update | . | . ",
    "url": "http://localhost:4000/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#secondary-indexes",
    "relUrl": "/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#secondary-indexes"
  },"14": {
    "doc": "Ch6 - Partitioning",
    "title": "Rebalancing Partitions",
    "hpath": "books.tech.data-intensive-applications.ch6-partitioning",
    "content": ". | Fixed number of partitions . | more partitions than nodes | when new node join, steal partitions from others | Used in Riak, Elasticsearch, Couchbase, and Voldemort | hard to pick the right number of partitions | . | parition spliting and merging | # of partition proportionally to nodes . | when a new node joins the cluster, it randomly chooses a fixed number of existing partitions to split, and then takes ownership of half of each partition | used by Cassandra | . | . | auto vs manual rebalancing . | full automation can be dangerous in combination with automatic failure detection | . | . ",
    "url": "http://localhost:4000/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#rebalancing-partitions",
    "relUrl": "/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#rebalancing-partitions"
  },"15": {
    "doc": "Ch6 - Partitioning",
    "title": "Request Routing",
    "hpath": "books.tech.data-intensive-applications.ch6-partitioning",
    "content": ". | require consensus . | use zookeeper - HBase, SolrCloud, Kafka, Espresso | gossip - Cassandra and Riak | no autobalancing, routing tier - couchbase | . | . ",
    "url": "http://localhost:4000/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#request-routing",
    "relUrl": "/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html#request-routing"
  },"16": {
    "doc": "Ch6 - Partitioning",
    "title": "Ch6 - Partitioning",
    "hpath": "books.tech.data-intensive-applications.ch6-partitioning",
    "content": ". | Partitioned databases were pioneered in the 1980s by products such as Teradata, rediscvoered by noSQL | . ",
    "url": "http://localhost:4000/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html",
    "relUrl": "/notes/c61cfa31-05a8-47de-897d-0fbd0a884e69.html"
  },"17": {
    "doc": "Book",
    "title": "Book",
    "hpath": "books",
    "content": " ",
    "url": "http://localhost:4000/notes/d088ab77-c2f6-4f7a-be4a-7597b00daff0.html",
    "relUrl": "/notes/d088ab77-c2f6-4f7a-be4a-7597b00daff0.html"
  },"18": {
    "doc": "Ch4 - Encoding and evolution",
    "title": "Chapter 4: Encoding and evolution",
    "hpath": "books.tech.data-intensive-applications.ch4-encoding",
    "content": ". | Backward compatibility: Newer code can read data that was written by older code. | Forward compatibility: Older code can read data that was written by newer code. | . ",
    "url": "http://localhost:4000/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html#chapter-4-encoding-and-evolution",
    "relUrl": "/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html#chapter-4-encoding-and-evolution"
  },"19": {
    "doc": "Ch4 - Encoding and evolution",
    "title": "Formats of encoding",
    "hpath": "books.tech.data-intensive-applications.ch4-encoding",
    "content": "Lang specific format . | Tied to a particular langaguage | Security concern - decoding process needs to be able to instantiate arbitrary classes | Versioning is after thought | . JSON, XML, CSV . | Usually good choice for comm between organizations | Problems: . | ambiguity around the encoding of numbers. | e.g. large numbers - integers greater than 2^53 cannot be exactly represented in floating point in javascript | . | Lack support for binary string - base64 enciding as workaround. – increase data size by 33% | Schema support not widely used. Decoding logic needs hardcoding | . | . Binary format . | Benefits . | More compact (JSON etc. needs to be self describing. Lots of space used in each record) | The schema is a valuable form of documentation | Keeping a database of schemas allows you to check forward and backward compatibility of schema changes, before anything is deployed. | Code gen for static typed languages | . | . | Apach Thrift (originally Facebook) and ProtoBuf (ori. Google) . | example Protobuf schema message Person { required string user_name = 1; optional int64 favorite_number = 2; repeated string interests = 3; } . | Field tags and schema evolution . | Each field contain the tag number and value | Tag number can’t change | Protobuf has no list type, but repeated flag - can evolve from single to repeated | Thrift has dedicated list type =&gt; supports nested lists | . | . | Avro - designed for hadoop . | No reference to field tag | Record appear in order | Translate between The writer’s schema and the reader’s schema | To maintain compatibility, you must only add or remove a field that has a default value | how to find writer schema: different options . | Large file with lots of records - include the writer’s schema once at the beginning of the large file | Version number + database to look up schema | Negotiate version on connection setup - AVRO RPC | . | Benefit: . | Support dynamically generated schemas - e.g. no need to hardcode translation between DB columns and schema if doing a dump | Code generation and dynamically typed languages - Thrift and Protocol Buffers rely on code generation, not great for dynamic lang. In Avro code gen is optional - for dynamic type, can read directly | . | . | . The Merits of Schemas . | Many DBs proprietary binary encoding: JDBC/ODBC driver can decode responses from the DBs’s network protocol into in-memory data structures. | Thrift, Protobuf and Avro all support schema, but simpler than XML or json (e.g. regex constraints) | . ",
    "url": "http://localhost:4000/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html#formats-of-encoding",
    "relUrl": "/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html#formats-of-encoding"
  },"20": {
    "doc": "Ch4 - Encoding and evolution",
    "title": "Modes of dataflow",
    "hpath": "books.tech.data-intensive-applications.ch4-encoding",
    "content": "Through Databases . | Backward compatibility is clearly necessary: same client, newer version needs to read older writes | Forward compatibility is also needed: newer client writes a record, a older client reads | Common error: newer client adds a field, older client update the row, that unknown field get dropped– if it can’t parse new field, should keep as-is | Data outlives code: App updates fast. Data from a long time ago is still stored . | Schema evolution thus allows the entire database to appear as if it was encoded with a single schema, even though the underlying storage may contain records encoded with various historical versions of the schema. | . | Archival storage: . | data dump will typically be encoded using the latest schema | Avro object container often good fit - or parquet for analytic friendliness | . | . Through Services: REST and RPC . | REST is not a protocol, but rather a design philosophy that builds upon the principles of HTTP - “REST-ful” . | URL as resource | HTTP features for cache control, authentication, and content type negotiation | it doesn’t try to hide the fact that it’s a network protocol | . | SOAP: . | avoid HTTP specific features | WSDL enables code generation so that a client can access a remote service using local classes and method calls - not as useful for dynamically typed languages | . | problems with RPCs pretending to be local calls - is flawed idea: . | Unpredictable, may require retry | may not know whether succeeded or failed (in case of timeout) | Retry and idempotence - request may be going through but didn’t get successful response | Latency longer | Passing data | . | REST is usually used for external comm, RPC may be internal | Evolution: . | can assume all the servers will be updated first, and all the clients second -&gt; only need backward compatibility on requests, and forward compatibility on responses. | REST api provider can store client APIs + version they are requesting to help manage. E.g. stripe . | Thrift, gRPC (Protocol Buffers), and Avro RPC can be evolved according to the compatibility rules of the respective encoding format | . | . | . Message-Passing Dataflow . | Actor programming model: communicates by send/receiving async messages. process one message at a time. assume message may be lost | Compared to RPC, less mismatch between local vs remote communication | example distributed actor frameworks: message broker + actor programming model . | Akka - Java’s built-in serialization by default -&gt; no fw/bw compatibility. supports using with ProtoBuf etc. to do rolling upgrades | Orleans - also support custom serailization plug-ins | Erlang OTP | . | . ",
    "url": "http://localhost:4000/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html#modes-of-dataflow",
    "relUrl": "/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html#modes-of-dataflow"
  },"21": {
    "doc": "Ch4 - Encoding and evolution",
    "title": "Ch4 - Encoding and evolution",
    "hpath": "books.tech.data-intensive-applications.ch4-encoding",
    "content": " ",
    "url": "http://localhost:4000/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html",
    "relUrl": "/notes/e22dd5a3-f940-4548-b1d7-22a26b5386ce.html"
  },"22": {
    "doc": "Tech",
    "title": "Tech",
    "hpath": "books.tech",
    "content": " ",
    "url": "http://localhost:4000/notes/ede45f4d-8d30-42a9-bd27-f1b3ba37d6e0.html",
    "relUrl": "/notes/ede45f4d-8d30-42a9-bd27-f1b3ba37d6e0.html"
  },"23": {
    "doc": "Root",
    "title": "My notes",
    "hpath": "root",
    "content": "Hello there! This is where I keep and share my notes on books, tech, travel, and other hobbies :) . ",
    "url": "http://localhost:4000/#my-notes",
    "relUrl": "/#my-notes"
  },"24": {
    "doc": "Root",
    "title": "Root",
    "hpath": "root",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
}
